# this is the language (GraphQL Schemea)
# "What questions are allowed?"
# Why this structure works
#  Enums first (vocab)
# Inputs next (questions)
# Leaf types (small objects)
# Aggregate types (Decision)

# Root types last (Query)

# Lists -> homogeneous (same type for all elements), and ordered
# GraphQL doesn't allow tuples
# Int
# Float
# String
# Boolean
# ID - only allowed types in Graphql rest are custom scalars

# allows - enums, input objects
# doesn't allow - Dictionaries / maps, Tuples, Arbitrary JSON objects, Dynamic keys, Unstructured blobs (without custom scalars)

export const typeDefinitionSchema = `
  enum PrimitiveEventType {
    AgentJoined
    ResourceAdded
    AgentRequested
    TimeAdvanced
  }

  input PrimitiveEventInput {
    type: PrimitiveEventType!
    agentId: ID
    amount: Int
    capacity: Int
    tick: Int
  }
  
  type AllocationEntry {
    agentId: ID!
    amount: Int!
  }

  type Reason {
    kind: String!
    agentId: ID
    ratio: Float
    ticks: Int
    variance: Float
  }

  type Decision {
    options: [DecisionOption!]!
  }

  type Query {
    decision(
      events: [PrimitiveEventInput!]!
      seed: Int!
      topK: Int = 5
    ): Decision!
  }

  type DecisionOption {
    allocation: [AllocationEntry!]!
    score: Float!
    reasons: [Reason!]!
  }
`

